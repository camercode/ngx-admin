"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var overview_1 = require("../../model/class/overview");
var ExamplesParser = /** @class */ (function () {
    function ExamplesParser() {
    }
    ExamplesParser.prototype.getNodes = function (example) {
        if (example.tag.startsWith(overview_1.OverviewNodeType.INLINE_EXAMPLE)) {
            return this.parseInlineTag(example);
        }
        if (example.tag.startsWith(overview_1.OverviewNodeType.LIVE_EXAMPLE)) {
            return this.parseLiveTag(example);
        }
        if (example.tag.startsWith(overview_1.OverviewNodeType.STACKED_EXAMPLE)) {
            return this.parseStackedTag(example);
        }
        if (example.tag.startsWith(overview_1.OverviewNodeType.ADDITIONAL_EXAMPLE)) {
            return this.parseAdditionalTag(example);
        }
    };
    ExamplesParser.prototype.parseInlineTag = function (example) {
        return this.parse(example, overview_1.OverviewNodeType.INLINE_EXAMPLE, this.parseInlineExample);
    };
    ExamplesParser.prototype.parseLiveTag = function (example) {
        return this.parse(example, overview_1.OverviewNodeType.LIVE_EXAMPLE, this.parseExample);
    };
    ExamplesParser.prototype.parseStackedTag = function (example) {
        return this.parse(example, overview_1.OverviewNodeType.STACKED_EXAMPLE, this.parseExample);
    };
    ExamplesParser.prototype.parseAdditionalTag = function (example) {
        return this.parse(example, overview_1.OverviewNodeType.ADDITIONAL_EXAMPLE, this.parseExample);
    };
    ExamplesParser.prototype.parse = function (example, exampleType, parser) {
        var _a = this.prepareExample(example), tag = _a.tag, comment = _a.comment;
        return this.createNodes(exampleType, parser.call(this, tag), comment);
    };
    ExamplesParser.prototype.prepareExample = function (example) {
        var _a = example.tag.split('('), type = _a[0], name = _a[1];
        var tagFinish = example.text.indexOf(')') + 1;
        var tag = type + "(" + this.handleName(name) + example.text.substring(0, tagFinish);
        var comment = example.text.substring(tagFinish).trim();
        return { tag: tag, comment: comment };
    };
    ExamplesParser.prototype.createNodes = function (exampleType, example, comment) {
        return [
            { type: exampleType, content: example },
            { type: overview_1.OverviewNodeType.TEXT, content: comment },
        ];
    };
    /**
     * Parses with the following pattern:
     * inline-example(name, example-id, lang, row-start, row-end)
     *
     * @example:
     * inline-example(Super example, some-component/some.component.ts, 21, 46)
     * inline-example(Super example, some-component/some.component)
     * */
    ExamplesParser.prototype.parseInlineExample = function (raw) {
        var _a = this.parseRaw(raw), name = _a[0], id = _a[1], firstLine = _a[2], lastLine = _a[3];
        return {
            name: name,
            id: id,
            firstLine: +firstLine,
            lastLine: +lastLine,
        };
    };
    /**
     * Parses with the following pattern:
     * inline-example(name, example-id)
     *
     * @example:
     * inline-example(Super example, some-component/some.component)
     * */
    ExamplesParser.prototype.parseExample = function (raw) {
        var _a = this.parseRaw(raw), name = _a[0], id = _a[1];
        return {
            name: name,
            id: id,
        };
    };
    ExamplesParser.prototype.parseRaw = function (raw) {
        var example = raw.match(/\((.*)\)/);
        if (!example) {
            throw new Error("Can't parse example: " + raw);
        }
        return example[1]
            .split(',')
            .map(function (item) { return item.trim(); });
    };
    ExamplesParser.prototype.handleName = function (str) {
        var capitalized = str.charAt(0).toUpperCase() + str.slice(1);
        if (!capitalized.endsWith(',')) {
            return capitalized + ' ';
        }
        return capitalized;
    };
    return ExamplesParser;
}());
exports.ExamplesParser = ExamplesParser;
